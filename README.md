# Three-Tier-Distributed-Web-Based-Application
I created a distributed three-tier web-based application which uses servlets and JSP technology running on a Tomcat container/server to access and maintain a persistent MySQL database using JDBC.


project Description:  In this assignment you will utilize a suppliers/parts/jobs/shipments database (creation/population script available on Webcourses under Project 4) as the back-end database. Front-end access to this database by end users will occur through a single page displayed in the client’s web browser. The schema of the backend database consists of four tables with the following schemas for each table:

	suppliers (snum, sname, status, city)  //information about suppliers
	parts (pnum, pname, color, weight, city)  //information about parts
	jobs (jnum, jname, numworkers, city)  //information about jobs
   	shipments (snum, pnum, jnum, quantity)  //suppliers ship parts to jobs in specific quantities
	
The database will enforce referential integrity via foreign key constraints.  The primary key for the shipments table is a composite key consisting of three foreign keys (the primary keys in the suppliers, parts, and jobs tables).  Referential integrity means that a shipment record cannot exist unless it links back (via referential integrity) to existing entities on all foreign key values.  Thus, a shipment record cannot exist unless the referenced snum, pnum, and jnum already exist in their respective tables.

The first-tier (user-level front-end) of your web-application will consist of an HTML landing page which is used to authenticate end users.  The authentication of users is handled via a servlet in the webapp that validates the user entered credentials with those in a credentials file (a text file) maintained on the server-side.  The credentials file contains an unknown number of lines where each line contains a username and password separated by a comma (csv file format). Validation consists of matching both the user entered name and password against the values in the credentials file.  If the entered credentials do not match an credentials in the credentials file, the user will be denied access to the system. If a match is found, the authenticated the user will be automatically redirected to one of three different JSP pages. One which handles root-level user clients and one which handles non-root-level clients, that allow the users to enter arbitrary SQL commands into a window (i.e. a form) and submit them to a server application for processing.  The third JSP page will be consist of dedicated data entry forms for entering new records into the four tables in the database.  

The front-ends of all three user applications will utilize JSP technology.   The front-ends for the root-level and client-level users, will provide the user a simple form in which they will enter a SQL command (any DML, DDL, or DCL command could theoretically be entered by the user, however we will restrict to queries, insert, update, replace, and delete commands).  These two front-ends will provide only three buttons for the user, an “Execute Command” button that will cause the execution of the SQL command currently in the input window, a “Reset Form” button that simply clears any content currently in the form input area, and a “Clear Results” button that will erase the currently displayed data (user optional).  The third front-end will be utilized only by naïve data-entry users by filling in a form.  The data-entry users will not enter SQL commands to accomplish their tasks.  Rather, their web-application will use the preparedStatement interface and extract the parameters from their forms and issue the SQL command in the background.  The data-entry level front end will have two buttons on each form, one for entering the data and one for clearing data and results.

The front-ends will run on any web-based browser that you would like to use.  The applications will connect to the backend database via properties files dependent on which front-end page is utilized.  This connection must be handled using properties read from a properties file.  You will have three different properties files, one for the root-level users, one for the client-level users (all the same as project 3 except for the different database), and one for the data entry-level users.  The data-entry level user account is a new user that will need to be created, just as you created the client user for Project 3.

The second-tier servlets, are in charge of handling the SQL command interface for the users.  The root-level user app (and the data entry level app – see below), will also implement the server-side business/application logic.  This logic will increment by 5, the status of a supplier anytime that supplier is involved in the insertion/update of a shipment record in which the quantity is greater than or equal to 100.  Note that any update of quantity >= 100 will affect any supplier involved in a shipment with a quantity >= 100.  The example screen shots illustrate this case.  An insert of a shipment tuple (S5, P6, J7, 400) will cause the status of every supplier who has a shipment with a quantity of 100 or greater to be increased by 5.  In other words, even if a supplier’s shipment is not directly affected by the update, their status will be affected if they have any shipment with quantity >= 100.  (See page xxs for a bonus problem that implements a modified version of this business rule.)  The business logic of the second tier will reside in the servlets on the Tomcat web-application server (server-side application).  This means that the business logic is not to be implemented in the DBMS via a trigger.  

The client-level servlet will handle the SQL command interface, just as the root-level servlet does, however, due to the restrictions on the client-level privileges, no business-logic will be implemented in this application.

The data entry-level servlet will provide the user four templates (forms) for the each of the tables in the project4 database. The correct updating command will be executed by mid-tier level servlets issuing whichever updating commands are appropriate based on which form was submitted by the data-entry user.  The updating commands are executed by extracting the parameters from the form and issuing a prepared statement update to the correct database table.  You may want to refer to the JDBC notes from Module 3 to refresh your memory of how the preparedStatement() interface differs from the normal Statement() interface.

The third-tier (back-end) is the persistent MySQL database described above and is under control of the MySQL DBMS server.  You will create and maintain this database via the creation/population script.  See the important note below concerning when/how to re-run this script for your final submission.

